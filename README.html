<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Standalone Test Server</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Standalone-test-server</span> <span class="project-version">0.7.3-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="README.html"><div class="inner"><span>Standalone Test Server</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>standalone-test-server</span></div></div></li><li class="depth-2 branch"><a href="standalone-test-server.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="standalone-test-server.query.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>query</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#standalone-test-server" name="standalone-test-server"></a>Standalone Test Server</h1>
<p><a href="https://circleci.com/gh/Mayvenn/standalone-test-server"><img src="https://circleci.com/gh/Mayvenn/standalone-test-server.svg?style=svg&amp;circle-token=599f432978d381e2614f42ed892267b45dde78d9" alt="Circle CI" /></a> <a href="http://mayvenn.github.io/standalone-test-server/standalone-test-server.core.html">Documentation</a> <a href="https://clojars.org/standalone-test-server"><img src="https://img.shields.io/clojars/v/standalone-test-server.svg" alt="Clojars Project" /></a></p>
<p>A simple clojure HTTP ring handler to test HTTP requests.</p>
<p>Instead of mocking or stubbing HTTP requests, this library can spawn a basic web server that runs any ring handler while recording all incoming requests.</p>
<p>We use it at Mayvenn to simulate external apis in our tests. We’ve written a short <a href="http://engineering.mayvenn.com/2015/06/26/Testing-External-HTTP-Requests/">blog post</a> to help explain some of the motivation/reasoning behind this small library.</p>
<h2><a href="#installation" name="installation"></a>Installation</h2>
<p>Add this line to your <code>:dependencies</code> key for your project.clj:</p>
<pre><code class="clojure">[standalone-test-server "0.7.2"]
</code></pre>
<p>Then you can require it using:</p>
<pre><code class="clojure">(ns my-system.tests
  (:require [standalone-test-server.core :as sts]))
</code></pre>
<h2><a href="#usage" name="usage"></a>Usage</h2>
<p>There are only two functions and one macro. But they are usually used together to form a test case.</p>
<h3><a href="#standalone-server" name="standalone-server"></a>standalone-server</h3>
<p>A wrapper around <a href="https://github.com/ring-clojure/ring/tree/master/ring-jetty-adapter">ring.adapter.jetty</a>’s <code>run-jetty</code> function.</p>
<p>Like <code>run-jetty</code>, it expects a ring handler and some (optional) config.</p>
<pre><code class="clojure">(let [server (sts/standalone-server (constantly {:status 201, :body "hi"})
                                    {:port 4334})]
  (try
    ;; Make requests which need an HTTP server listening at a specific port
    (http/get "http://localhost:4334/endpoint")
    (finally
      (.stop server))))
</code></pre>
<h3><a href="#with-standalone-server-macro-" name="with-standalone-server-macro-"></a>with-standalone-server (macro)</h3>
<p>You can avoid the let-try-finally boilerplate of <code>standalone-server</code> with the <code>with-standalone-server</code> macro.</p>
<p>It assumes the first binding is the server:</p>
<pre><code class="clojure">(sts/with-standalone-server [server (sts/standalone-server (constantly {:status 201, :body "hi"}))]
  ;; perform requests
  ;; macro ensures `(.stop server)`
  )
</code></pre>
<h3><a href="#with-requests-chan" name="with-requests-chan"></a>with-requests-chan</h3>
<p>When you want to record the requests that pass through a <code>standalone-server</code>, use <code>with-requests-chan</code>.</p>
<p>This function creates (or wraps - see below) a ring middleware handler. It returns a tuple: the first item is a channel containing the requests the handler receives; the second item is a modified handler to pass to the <code>standalone-server</code>.</p>
<pre><code class="clojure">(let [[requests handler] (sts/with-requests-chan)]
  (sts/with-standalone-server [s (sts/standalone-server handler)]
    (http/get "http://localhost:4334/endpoint")
    (is (core.async/&lt;!! requests))))
</code></pre>
<p>By default <code>with-requests-chan</code> uses a handler that returns a 200 empty body response. Alternatively, provide a <code>handler</code> as the underlying ring handler to call.</p>
<pre><code class="clojure">(let [[requests handler] (sts/with-requests-chan (constantly {:status 201, :body "hi"}))]
  (sts/with-standalone-server [s (sts/standalone-server handler)]
    (http/get "http://localhost:4334/endpoint")
    (is (= "hi" (:body (core.async/&lt;!! requests))))))
</code></pre>
<h2><a href="#waiting-for-asynchronous-requests" name="waiting-for-asynchronous-requests"></a>Waiting for asynchronous requests</h2>
<p>Many systems will make requests to the standalone server asynchronously. Tests usually want to wait until the requests have been made before making further assertions. Often the tests want to make assertions about the requests themselves, or some subset of the requests. If the system fails to produce the expected requests, the tests should not block forever.</p>
<p>For these scenarios, <code>txfm-requests</code> gathers and returns the asynchronous requests.</p>
<p>It takes a requests channel, a filter (a transducing function) and a timeout. If the requests satisfy the filter before the timeout this helper returns the requests. Otherwise, it returns as many matching requests as it has received so far.</p>
<pre><code class="clojure">(let [[requests handler] (sts/with-requests-chan)]
  (sts/with-standalone-server [s (sts/standalone-server handler)]
    ;; Trigger async code which will make requests...
    (future (http/get "http://localhost:4334/endpoint1"))
    (future (http/get "http://localhost:4334/endpoint2"))
    (is (= "endpoint2"
           (-&gt; requests
               (sts/txfm-requests (comp (filter #(= "endpoint2" (:uri %)))
                                        (take 1))
                                  {:timeout 1000})
               first
               :uri)))))
</code></pre>
<p>Most tests will look like this, so make sure you understand this format.</p>
<p>The filter should contain <code>(take n)</code> to avoid waiting for the whole timeout. With a limit like this, <code>txfm-requests</code> will return as soon as <code>n</code> matching requests have been found.</p>
<p>To avoid delays, mosts tests should include <code>(take n)</code>. One exception is if you don’t know how many requests will be made. In this case simply exclude the <code>take</code>. When the timeout is reached, you will see all the requests made so far.</p>
<pre><code class="clojure">(let [[requests handler] (sts/with-requests-chan)]
  (sts/with-standalone-server [s (sts/standalone-server handler)]
    ;; Trigger async code which will make unknown number of requests...
    ;; Following waits for one second, gathering as many requests as happen in
    ;; that period.
    (is (&lt; 0 (count (sts/txfm-requests requests conj {:timeout 1000}))))))
</code></pre>
<p>A shorter way to extract the first matching request is with <code>txfm-request</code>. This helper adds an implicit <code>(take 1)</code> to ensure it returns as quickly as possible.</p>
<pre><code class="clojure">(is (= "endpoint2"
       (-&gt; requests
           (sts/txfm-request (filter #(= "endpoint2" (:uri %)))
                             {:timeout 1000})
           :uri)))
</code></pre>
<p>Note that just because a request was recorded, doesn’t mean your system has received the response yet or even has had time to process it. You may still need to poll for whether your system has successfully processed the response.</p>
<h2><a href="#filtering-requests" name="filtering-requests"></a>Filtering requests</h2>
<p>The <code>query</code> namespace contains helpers for filtering collections of requests.</p>
<table>
  <thead>
    <tr>
      <th>Name </th>
      <th>Params </th>
      <th>Includes </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>with-uri </td>
      <td>uri coll </td>
      <td>Filters coll to requests with the given uri </td>
    </tr>
    <tr>
      <td>with-method </td>
      <td>method coll </td>
      <td>With the given request method </td>
    </tr>
    <tr>
      <td>with-query-keys </td>
      <td>key-set coll </td>
      <td>Matches key-set to the parsed query-string’s keys </td>
    </tr>
    <tr>
      <td>with-query-key-subset </td>
      <td>key-set coll </td>
      <td>Where key-set is a subset of the parsed query-string’s keys </td>
    </tr>
    <tr>
      <td>with-query-params </td>
      <td>kv-map coll </td>
      <td>Matches kv-map to the parsed query-string </td>
    </tr>
    <tr>
      <td>with-body-keys </td>
      <td>key-set coll </td>
      <td>Matches key-set to the parsed body’s keys </td>
    </tr>
    <tr>
      <td>with-body-key-subset </td>
      <td>key-set coll </td>
      <td>Where key-set is a subset of the parsed body keys </td>
    </tr>
    <tr>
      <td>with-body </td>
      <td>kv-map coll </td>
      <td>Matches kv-map to the parsed body </td>
    </tr>
  </tbody>
</table></div></div></div></body></html>