<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Standalone Test Server</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Standalone-test-server</span> <span class="project-version">0.7.1</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="README.html"><div class="inner"><span>Standalone Test Server</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>standalone-test-server</span></div></div></li><li class="depth-2 branch"><a href="standalone-test-server.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="standalone-test-server.query.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>query</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#standalone-test-server" name="standalone-test-server"></a>Standalone Test Server</h1>
<p><a href="https://circleci.com/gh/Mayvenn/standalone-test-server"><img src="https://circleci.com/gh/Mayvenn/standalone-test-server.svg?style=svg&amp;circle-token=599f432978d381e2614f42ed892267b45dde78d9" alt="Circle CI" /></a> <a href="http://mayvenn.github.io/standalone-test-server/standalone-test-server.core.html">Documentation</a></p>
<p>A simple clojure HTTP ring handler to test HTTP requests.</p>
<p>Instead of mocking or stubbing HTTP requests, this library can spawn a basic web server that runs any ring handler while recording all incoming requests.</p>
<p>We use it at Mayvenn to simulate external apis in our tests. We’ve written a short <a href="http://engineering.mayvenn.com/2015/06/26/Testing-External-HTTP-Requests/">blog post</a> to help explain some of the motivation/reasoning behind this small library.</p>
<h2><a href="#installation" name="installation"></a>Installation</h2>
<p>Add this line to your <code>:dependencies</code> key for your project.clj:</p>
<pre><code class="clojure">[standalone-test-server "0.6.1"]
</code></pre>
<p>Then you can require it using:</p>
<pre><code class="clojure">(ns ...
    (:require [standalone-test-server :refer [standalone-server
                                              recording-endpoint
                                              with-standalone-server]]))
</code></pre>
<h2><a href="#usage" name="usage"></a>Usage</h2>
<p>There are only two functions and one macro. But they are usually used together to form a test case.</p>
<h3><a href="#standalone-server" name="standalone-server"></a>standalone-server</h3>
<p>A wrapper around <a href="https://github.com/ring-clojure/ring/tree/master/ring-jetty-adapter">ring.adapter.jetty</a>’s <code>run-jetty</code> function.</p>
<p>Like <code>run-jetty</code>, it expects a ring handler and some (optional) config.</p>
<pre><code class="clojure">(let [server (standalone-server (constantly {:status 201, :body "hi"}))]
  (try
    (http/get "http://localhost:4334/endpoint") ;; NOTE: request port must match the standalone-server's port
    (finally
      (.stop server))))
</code></pre>
<h3><a href="#with-standalone-server-macro-" name="with-standalone-server-macro-"></a>with-standalone-server (macro)</h3>
<p>You can avoid the let-try-finally boilerplate of <code>standalone-server</code> with the <code>with-standalone-server</code> macro.</p>
<p>It assumes the first binding is the server:</p>
<pre><code class="clojure">(with-standalone-server [server (standalone-server (constantly {:status 201, :body "hi"}))]
  ;; perform requests
  ;; macro ensures `(.stop server)`
  )
</code></pre>
<h3><a href="#recording-endpoint" name="recording-endpoint"></a>recording-endpoint</h3>
<p><code>standalone-server</code> expects a handler. When you want to record the requests that pass through that handler, use <code>recording-endpoint</code>.</p>
<p>This function wraps (or creates - see below) a ring middleware handler. It returns a tuple: the first item is an atom containing the sequence of requests the handler has received; the second item is a modified handler to pass to the <code>standalone-server</code>.</p>
<pre><code class="clojure">(let [[requests handler] (recording-endpoint)]
  (with-standalone-server [s (standalone-server handler)]
    (http/get "http://localhost:4334/endpoint")
    (is (= 1 (count @requests)))))
</code></pre>
<p>You can provide a <code>:handler</code> as the underlying ring handler to call. If none is provided, it uses a default that returns a 200 empty body response.</p>
<pre><code class="clojure">(let [[requests handler]
      (recording-endpoint {:handler (constantly {:status 201, :body "hi"})})]
  (with-standalone-server [s (standalone-server handler)]
    (let [response (http/get "http://localhost:4334/endpoint")]
      (is (= 1 (count @requests)))
      (is (= (:body response) "hi")))))
</code></pre>
<p>Most tests will look like this, so make sure you understand this format.</p>
<h2><a href="#waiting-for-asynchronous-requests" name="waiting-for-asynchronous-requests"></a>Waiting for asynchronous requests</h2>
<p>Many systems will make requests to the standalone server asynchronously. Tests usually want to block until the requests have been made before making further assertions. There are several helpers for waiting until the requests meet a condition before continuing. They are all based on the <code>requests-meet?</code> helper.</p>
<p>This helper takes a requests atom and a predicate. If the requests satisfy the predicate before the timeout this helper returns true. Otherwise, it returns false.</p>
<pre><code class="clojure">(let [[requests handler] (recording-endpoint)]
  (with-standalone-server [s (standalone-server handler)]
    ;; Trigger async code which will make request...
    (is (requests-meet? requests #(= 1 (count %)) {:timeout 1000}))
    ;; Assertions about how system has changed after receiving response...
    ))
</code></pre>
<p>A shorter way to do the above is <code>(is (requests-count? requests 1))</code>. You can also check <code>(is (requests-min-count? requests 1))</code> if you want to wait for <em>at least</em> one request.</p>
<p>Note that just because a request was recorded, doesn’t mean your system has received the response yet or even has had time to process it. You may still need to poll for whether your system has successfully processed the response.</p>
<p>If you don’t know how many requests will be made and just want to wait until the server has stopped receiving them, use <code>requests-quiescent</code>:</p>
<pre><code class="clojure">(let [[requests handler] (recording-endpoint)]
  (with-standalone-server [s (standalone-server handler)]
    ;; Trigger async code which will make unknown number of requests...
    (requests-quiescent requests {:for-ms 1000})))
</code></pre>
<p>Note that <code>requests-quiescent</code> will always take at least <code>for-ms</code> to return. This is because it starts a timer when it is called, resets the timer after every new request, and waits for the timer to expire before declaring quiescence.</p>
<p>Because of this, your tests will be much faster if you can use <code>requests-count?</code>.</p>
<h2><a href="#filtering-requests" name="filtering-requests"></a>Filtering requests</h2>
<p>The <code>query</code> namespace contains helpers for filtering collections of requests.</p>
<table>
  <thead>
    <tr>
      <th>Name </th>
      <th>Params </th>
      <th>Includes </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>with-uri </td>
      <td>uri coll </td>
      <td>Filters coll to requests with the given uri </td>
    </tr>
    <tr>
      <td>with-method </td>
      <td>method coll </td>
      <td>With the given request method </td>
    </tr>
    <tr>
      <td>with-query-keys </td>
      <td>key-set coll </td>
      <td>Matches key-set to the parsed query-string’s keys </td>
    </tr>
    <tr>
      <td>with-query-key-subset </td>
      <td>key-set coll </td>
      <td>Where key-set is a subset of the parsed query-string’s keys </td>
    </tr>
    <tr>
      <td>with-query-params </td>
      <td>kv-map coll </td>
      <td>Matches kv-map to the parsed query-string </td>
    </tr>
    <tr>
      <td>with-body-keys </td>
      <td>key-set coll </td>
      <td>Matches key-set to the parsed body’s keys </td>
    </tr>
    <tr>
      <td>with-body-key-subset </td>
      <td>key-set coll </td>
      <td>Where key-set is a subset of the parsed body keys </td>
    </tr>
    <tr>
      <td>with-body </td>
      <td>kv-map coll </td>
      <td>Matches kv-map to the parsed body </td>
    </tr>
  </tbody>
</table></div></div></div></body></html>